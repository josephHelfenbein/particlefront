#version 450

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, rgba16f) uniform writeonly image2D outSSR;
layout(binding = 1) uniform sampler2D lightingTex;
layout(binding = 2) uniform sampler2D depthTex;
layout(binding = 3) uniform sampler2D normalTex;

layout(push_constant) uniform PushConstants {
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;
} pc;

const int MAX_STEPS = 128;
const float MAX_DISTANCE = 50.0;
const float THICKNESS = 0.5;
const int BINARY_SEARCH_ITERATIONS = 8;

float hash(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

vec3 reconstructViewPosition(vec2 uv, float depth) {
    vec4 clipSpace = vec4(uv * 2.0 - 1.0, depth, 1.0);
    vec4 viewSpace = pc.invProj * clipSpace;
    viewSpace /= viewSpace.w;
    return viewSpace.xyz;
}

vec3 viewToScreenSpace(vec3 viewPos) {
    vec4 clipSpace = pc.proj * vec4(viewPos, 1.0);
    clipSpace.xyz /= clipSpace.w;
    vec3 screenSpace;
    screenSpace.xy = clipSpace.xy * 0.5 + 0.5;
    screenSpace.z = clipSpace.z;
    return screenSpace;
}

bool rayMarch(vec3 rayStartView, vec3 rayDirView, float jitter, out vec2 hitUV, out float hitDepth, out float rayLength) {
    vec3 currentPosView = rayStartView;
    
    float stepSize = 0.05;
    vec3 rayDirNorm = normalize(rayDirView);
    
    currentPosView += rayDirNorm * stepSize * jitter;
    
    vec3 prevPosView = currentPosView;
    
    for (int i = 0; i < MAX_STEPS; i++) {
        float dist = length(currentPosView - rayStartView);
        if (dist > MAX_DISTANCE) {
            return false;
        }
        
        stepSize = mix(0.05, 0.5, dist / MAX_DISTANCE);
        vec3 stepDirView = rayDirNorm * stepSize;
        
        currentPosView += stepDirView;
        
        vec3 screenPos = viewToScreenSpace(currentPosView);
        
        if (screenPos.x < 0.0 || screenPos.x > 1.0 || 
            screenPos.y < 0.0 || screenPos.y > 1.0 ||
            screenPos.z < 0.0 || screenPos.z > 1.0) {
            return false;
        }
        
        float sampledDepth = texture(depthTex, screenPos.xy).r;
        vec3 sampledViewPos = reconstructViewPosition(screenPos.xy, sampledDepth);
        
        float depthDiff = sampledViewPos.z - currentPosView.z;
        
        float adaptiveThickness = max(THICKNESS, stepSize * 1.5);
        
        if (depthDiff > 0.0 && depthDiff < adaptiveThickness) {
            vec3 binaryStart = prevPosView;
            vec3 binaryEnd = currentPosView;
            
            for (int j = 0; j < BINARY_SEARCH_ITERATIONS; j++) {
                vec3 binaryMid = mix(binaryStart, binaryEnd, 0.5);
                vec3 binaryScreen = viewToScreenSpace(binaryMid);
                
                float binarySampledDepth = texture(depthTex, binaryScreen.xy).r;
                vec3 binarySampledViewPos = reconstructViewPosition(binaryScreen.xy, binarySampledDepth);
                
                if (binarySampledViewPos.z - binaryMid.z > 0.0) {
                    binaryStart = binaryMid;
                } else {
                    binaryEnd = binaryMid;
                }
            }
            
            vec3 finalViewPos = mix(binaryStart, binaryEnd, 0.5);
            vec3 finalScreen = viewToScreenSpace(finalViewPos);
            hitUV = finalScreen.xy;
            hitDepth = finalScreen.z;
            rayLength = length(finalViewPos - rayStartView);
            return true;
        }
        
        prevPosView = currentPosView;
    }
    
    return false;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outSSR);
    if (pixel.x >= imageSize.x || pixel.y >= imageSize.y) {
        return;
    }
    
    vec2 uv = (vec2(pixel) + 0.5) / vec2(imageSize);
    float depth = texture(depthTex, uv).r;
    vec3 normal = texture(normalTex, uv).xyz * 2.0 - 1.0;
    
    vec3 viewPos = reconstructViewPosition(uv, depth);
    vec3 normalView = (pc.view * vec4(normal, 0.0)).xyz;
    normalView = normalize(normalView);
    
    vec3 viewDir = normalize(-viewPos);
    vec3 reflectDir = reflect(-viewDir, normalView);
    
    if (reflectDir.z > 0.0) {
        imageStore(outSSR, pixel, vec4(0.0));
        return;
    }
    
    float facingRatio = max(dot(normalView, viewDir), 0.0);
    if (facingRatio < 0.05) {
        imageStore(outSSR, pixel, vec4(0.0));
        return;
    }
    
    float jitter = hash(uv + fract(float(imageSize.x) * 0.001));
    
    vec2 hitUV;
    float hitDepth;
    float rayLength;
    bool hit = rayMarch(viewPos, reflectDir, jitter, hitUV, hitDepth, rayLength);
    
    if (hit) {
        float mipLevel = clamp(rayLength * 0.1, 0.0, 4.0);
        vec4 reflectionColor = textureLod(lightingTex, hitUV, mipLevel);
        
        vec2 edgeFade = smoothstep(0.0, 0.1, hitUV) * smoothstep(1.0, 0.9, hitUV);
        float edgeFactor = min(edgeFade.x, edgeFade.y);
        
        float fresnelFactor = pow(1.0 - facingRatio, 3.0);
        
        float distanceFade = 1.0 - smoothstep(MAX_DISTANCE * 0.7, MAX_DISTANCE, rayLength);
        
        float finalAlpha = reflectionColor.a * edgeFactor * fresnelFactor * distanceFade;
        
        imageStore(outSSR, pixel, vec4(reflectionColor.rgb, finalAlpha));
    } else {
        imageStore(outSSR, pixel, vec4(0.0));
    }
}